/**
 * Enhanced Payment Verification with Optional Security
 * Maintains working payment flow while enabling enhanced security
 */

import { 
  getPaymentRecordByTransactionId,
  createPaymentRecord as dbCreatePaymentRecord,
  updatePaymentRecordStatus as dbUpdatePaymentRecordStatus,
  getPendingPaymentRecordsByUser as dbGetPendingPaymentRecordsByUser,
  updatePaymentRecordTransactionId as dbUpdatePaymentRecordTransactionId,
  generateSecureNonce,
  createSecurePaymentRecord,
  verifyTransactionAtomic,
} from "@/lib/database";

export async function createPaymentRecord(paymentData: {
  user_id: string;
  transaction_id: string;
  expected_amount: number;
  token: string;
  recipient: string;
}) {
  try {
    const result = await dbCreatePaymentRecord({
      user_id: paymentData.user_id,
      transaction_id: paymentData.transaction_id,
      expected_amount: paymentData.expected_amount,
      token: paymentData.token as "USDC" | "USDT" | "CASH",
      recipient: paymentData.recipient,
    });

    return {
      success: true,
      data: result,
    };
  } catch (error) {
    console.error("Error creating payment record:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

export async function getPaymentRecordByTransactionIdCompat(transactionId: string) {
  try {
    const record = await getPaymentRecordByTransactionId(transactionId);
    return record;
  } catch (error) {
    console.error("Error getting payment record:", error);
    return null;
  }
}

export async function updatePaymentRecordStatusCompat(
  transactionId: string,
  status: "pending" | "confirmed" | "failed"
) {
  try {
    const result = await dbUpdatePaymentRecordStatus(transactionId, status);
    return result;
  } catch (error) {
    console.error("Error updating payment record status:", error);
    return false;
  }
}

export async function getPendingPaymentRecordsByUserCompat(
  userId: string,
  minutesBack: number = 10
) {
  try {
    const records = await dbGetPendingPaymentRecordsByUser(userId, minutesBack);
    return records;
  } catch (error) {
    console.error("Error getting pending payment records:", error);
    return [];
  }
}

export async function updatePaymentRecordTransactionIdCompat(
  tempTransactionId: string,
  actualTransactionId: string
) {
  try {
    const result = await dbUpdatePaymentRecordTransactionId(
      tempTransactionId,
      actualTransactionId
    );
    return result;
  } catch (error) {
    console.error("Error updating payment record transaction ID:", error);
    return false;
  }
}

/**
 * Enhanced payment verification with optional security features
 * Tries security features first, falls back to basic verification if they fail
 */
export async function verifyPaymentWithOptionalSecurity({
  transactionId,
  expectedAmount,
  expectedToken,
  userId,
  x402Service,
}: {
  transactionId: string;
  expectedAmount: number;
  expectedToken: string;
  userId: string;
  x402Service: {
    verifySolanaPayment: (
      transactionId: string,
      userId: string,
      expectedAmount?: number,
      expectedToken?: "USDC" | "USDT" | "CASH"
    ) => Promise<{
      success: boolean;
      creditsAdded?: number;
      error?: string;
    }>;
  };
}) {
  let securityMethod = "basic";
  let nonce = null;

  try {
    // Step 1: Check if transaction already processed (basic replay prevention)
    const existingRecord = await getPaymentRecordByTransactionIdCompat(transactionId);
    if (existingRecord && existingRecord.verified_at) {
      return {
        success: false,
        error: "Transaction has already been processed",
        alreadyProcessed: true,
        securityMethod,
      };
    }

    // Step 2: Try enhanced security features first
    try {
      // Generate nonce for enhanced security
      nonce = generateSecureNonce();
      
      // Try to create secure payment record
      const secureResult = await createSecurePaymentRecord(
        userId,
        transactionId,
        expectedAmount,
        expectedToken,
        process.env.NEXT_PUBLIC_PAYMENT_WALLET || "YOUR_WALLET_ADDRESS",
        nonce,
        5 // 5-minute timeout
      );

      if (secureResult.success) {
        securityMethod = "enhanced";
        console.log("ðŸ”’ Enhanced security enabled for transaction:", transactionId);
      } else {
        console.warn("ðŸ”’ Enhanced security unavailable, using basic verification");
        nonce = null; // Reset nonce if enhanced security fails
      }
    } catch (securityError) {
      console.warn("ðŸ”’ Security features unavailable, falling back to basic verification:", securityError);
      nonce = null; // Reset nonce if enhanced security fails
    }

    // Step 3: Verify the payment using the server-side service
    const result = await x402Service.verifySolanaPayment(
      transactionId,
      userId,
      expectedAmount,
      expectedToken as "USDC" | "USDT" | "CASH"
    );

    // Step 4: Process verification results
    if (result.success && result.creditsAdded && result.creditsAdded > 0) {
      // Create or update payment record if needed
      if (!existingRecord) {
        const recordResult = await createPaymentRecord({
          user_id: userId,
          transaction_id: transactionId,
          expected_amount: expectedAmount,
          token: expectedToken,
          recipient: process.env.NEXT_PUBLIC_PAYMENT_WALLET || "YOUR_WALLET_ADDRESS",
        });

        if (!recordResult.success) {
          console.warn("Failed to create payment record, but continuing verification");
        }
      }

      // Update status to confirmed
      await updatePaymentRecordStatusCompat(transactionId, "confirmed");

      // Step 5: Try atomic verification if security method was enhanced
      if (securityMethod === "enhanced" && nonce) {
        try {
          console.log("ðŸ”’ Starting atomic transaction verification with nonce:", nonce);
          
          const atomicResult = await verifyTransactionAtomic(
            transactionId,
            nonce,
            true // verification successful
          );

          if (atomicResult.success) {
            console.log("ðŸ”’ Atomic verification successful, security method:", securityMethod);
            return {
              success: true,
              creditsAdded: result.creditsAdded,
              transactionId,
              securityMethod,
              nonce,
            };
          } else {
            console.warn("ðŸ”’ Atomic verification failed, falling back to basic method");
            securityMethod = "basic";
          }
        } catch (atomicError) {
          console.warn("ðŸ”’ Atomic verification unavailable, using basic method:", atomicError);
          securityMethod = "basic";
        }
      }

      // Basic verification success
      console.log("ðŸ’³ Basic payment verification successful, security method:", securityMethod);
      return {
        success: true,
        creditsAdded: result.creditsAdded,
        transactionId,
        securityMethod,
      };
    } else {
      // Payment verification failed
      if (existingRecord) {
        await updatePaymentRecordStatusCompat(transactionId, "failed");
      }

      return {
        success: false,
        error: result.error || "Payment verification failed",
        securityMethod,
      };
    }
  } catch (error) {
    console.error("Error in payment verification with optional security:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown verification error",
      securityMethod,
    };
  }
}

/**
 * Get security status information for monitoring
 */
export async function getSecurityStatus(transactionId: string) {
  try {
    const record = await getPaymentRecordByTransactionIdCompat(transactionId);
    if (!record) {
      return {
        securityEnabled: false,
        hasNonce: false,
        securityMethod: "unknown",
      };
    }

    return {
      securityEnabled: !!record.transaction_nonce,
      hasNonce: !!record.transaction_nonce,
      securityMethod: record.transaction_nonce ? "enhanced" : "basic",
      verifiedAt: record.verified_at,
      nonce: record.transaction_nonce ? record.transaction_nonce.substring(0, 8) + "..." : null,
    };
  } catch (error) {
    console.error("Error getting security status:", error);
    return {
      securityEnabled: false,
      hasNonce: false,
      securityMethod: "error",
    };
  }
}